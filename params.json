{"name":"Mpcpy","tagline":"","body":"# mpcpy\r\n\r\nA group of classes to run model predictive control (MPC) simulations using python and Dymola.\r\n\r\n\r\n## Workflow\r\nIn a model predictive control simulation we need several components.\r\nAt first we need an emulator to replace the real world system in our computational environment.\r\nThe system is subjected to certain boundary conditions which may vary.\r\nNext we need a controller which will determine the inputs we must supply to the emulated system so it moves in the wanted direction.\r\nAs we are considering MPC the controller will consist of a state estimation, a prediction and an optimization\r\n\r\nFor each of these components base classes are included in mpcpy.\r\nSome of these classes can be used out off the box, others require child class creation which will be explained below.\r\n\r\nbefore we start import the package\r\n```\r\nimport mpcpy.Emulator \r\n```\r\n\r\n### Emulator\r\nThe most important method in the emulator class it the __call__ method.\r\nThis method should have the inputs to the emulator as arguments and append the results to it's \"res\" property.\r\nBy default a dympy Dympola connection is assumed to do the simulation work but the class can be adapted to use other simulation tools.\r\n\r\n\r\ni.e.\r\nif we have a dymola model opend and compyled with dympy with 3 inputs \"T_amb\",\"Q_flow_sol\",\"Q_flow_hp\" you can create an emulator object like this:\r\n```\r\nemulator = mpcpy.Emulator(dymola,['T_amb','Q_flow_sol','Q_flow_hp'])\r\n```\r\n\r\n\r\n### Boundary conditions\r\n\r\n\r\n### Control\r\n#### State estimation\r\n#### Prediction\r\n\r\n\r\n\r\n\r\n\r\n### MPC\r\n\r\n\r\n\r\n\r\n\r\n# Cplex in Python\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}