{"name":"mpcpy","tagline":"","body":"# mpcpy\r\nA group of classes to run model predictive control (MPC) simulations using python and Dymola.\r\n\r\n\r\n# Workflow\r\nIn a model predictive control simulation we need several components.\r\nAt first we need an emulator to replace the real world system in our computational environment.\r\nThe system is subjected to certain boundary conditions which may vary.\r\nNext we need a controller which will determine the inputs we must supply to the emulated system so it moves in the wanted direction.\r\nAs we are considering MPC the controller will consist of a state estimation, a prediction and an optimization\r\n\r\nFor each of these components base classes are included in mpcpy.\r\nSome of these classes can be used out off the box, others require child class creation which will be explained below.\r\n\r\nbefore we start import the package and numpy\r\n```\r\nimport numpy as np\r\nimport mpcpy\r\n```\r\n\r\n## Boundary conditions\r\nAs all systems are subject to some boundary conditions a Boundaryconditions class is constructed.\r\nThis class main purpose is to handle the interpolation of boundary conditions to the correct times (also for predictions which may lay outside of the emulation interval).\r\nBy default it assumes periodic boundary conditions but this can be altered to maintaining the first or last entry when time flows outside of the defined range by setting `periodic=False` as an argument on creation.\r\n\r\n#### Example:\r\n```\r\ntime = np.arange(0.,24.01*3600.,3600.)\r\nbcs = {'time': time,\r\n       'T_amb': 5 + 2*np.sin(2*np.pi*time/24./3600.)+273.15,\r\n       'Q_flow_sol': 500 + 500*np.sin(2*np.pi*time/24./3600.),\r\n       'p_el': 0.2 + 0.05*np.sin(2*np.pi*time/24./3600.),\r\n       'Q_flow_hp_max': 5000*np.ones_like(time),\r\n       'T_in_min': 20*np.ones_like(time)+273.15,\r\n       'T_em_max': 30*np.ones_like(time)+273.15}\r\nboundaryconditions = mpcpy.Boundaryconditions(bcs)\r\nprint( boundaryconditions(1800) )\r\nprint( boundaryconditions(24.5*3600) )\r\n```\r\n\r\n\r\n## Emulator\r\nThe emulator class creates objects used to emulate the system.\r\nBy default a [dympy](https://github.com/brechtba/dympy) Dymola connection is assumed to do the simulation work but the class can be adapted to use other simulation tools.\r\nWhen creating an object the inputs the model uses need to be specified as a list of strings. These inputs can be controlled inputs or disturbances.\r\nThere is also an optional argument `initializationtime` which controls the time used for initializing the model the default value is 1 second.\r\n\r\nThe object must have a `res` property where the results of the entire emulation are stored. This property is later used to output the results to the mpcpy object.\r\n\r\nModel parameters can be defined using the `set_parameters` method which accepts a dictionary with name, value pairs as argument. \r\nInitial conditions can be defined using the `set_initial_conditions` method which accepts a dictionary with name, value pairs as argument.\r\n\r\nEach model must be initialized before a simulation or mpc run using the `initialize`.\r\nThe initialization sets all parameter values and initial conditions and runs the simulation for a short period to get initial values for all variables in the `res` dictionary.\r\nThis way rewriting all parameters before every emulation is avoided which results in considerable speed gains.\r\n\r\nThe most important method in the emulator class it the `__call__` method.\r\nThis method should accepts an input dictionary with inputs to the emulator as only argument and append the results to it's `res` property.\r\n\r\n#### Example:\r\nFirst we need to open and compile a dymola model:\r\n```\r\nimport dympy\r\n\r\ndymola = dympy.Dymola()\r\ndymola.clear()\r\ndymola.openModel('example.mo')\r\ndymola.compile('example')\r\n```\r\n\r\nif we have a dymola model opened and compiled with dympy as `dymola` with 3 inputs `T_amb`, `Q_flow_sol`, `Q_flow_hp` and some parameters defined in Modelica which need to be set, \r\nyou can create and run an emulator object like this:\r\n\r\n\r\n```\r\nemulator = mpcpy.Emulator(dymola,['T_amb','Q_flow_sol','Q_flow_hp'])\r\ninp = {'time': [0., 3600., 7200.], 'T_amb': [273.15, 274.15, 275.15], 'Q_flow_sol': [500., 400., 300.], 'Q_flow_hp': [4000., 4000., 4000.]}\r\nemulator_parameters = {'C_em.C': 10e6, 'C_in.C': 5e6, 'UA_in_amb.G': 200, 'UA_em_in.G': 1600}\r\nemulator.set_parameters(emulator_parameters)\r\n\r\nemulator_initialconditions = {'C_em.T': 22+273.15, 'C_in.T': 21+273.15}\r\nemulator.set_initial_conditions(emulator_initialconditions)\r\n\r\nemulator.initialize()\r\nemulator(inp)\r\n\r\nprint( emulator.res['time'] )\r\nprint( emulator.res['C_in.T'] )\r\n```\r\n\r\n## Control\r\nThe control algorithm is MPC by default as this is the goal of the project, but it could be modified to use other control techniques at discrete time intervals.\r\nAn MPC consists of a state estimation, a prediction and a control optimization which will be explained below.\r\nThe basic principle of MPC is that a model suitable for optimization (for instance a linear or quadratic program or a smooth non-linear model) which represents the system behavior is constructed.\r\nEach time step the states of the optimization model are estimated based on measurements or the emulation model in our case.\r\nA prediction is made for the disturbances over a certain time period (the control horizon)\r\nThe model is optimized with respect to the control signals given the predictions and certain constraints and the first sample of the control signals are implemented in the emulator.\r\nThe system hopefully evolves in the desired direction and the next time step everything starts over.\r\n\r\n- refs on mpc\r\n\r\n### State estimation\r\nWe start by defining a state estimation object. A base class is supplied in mpcpy but due to the specific nature of every model this has to be extended for every MPC.\r\nDuring creation the estimation object has to be given an emulator object which contains the results from which the states can be estimated.\r\nThe implemented `__call__` method  take one argument, time and simply passes this to the `stateestimation` method and returns the result. \r\nThe intention is that the `stateestimation` method can be modified in a child class without affecting the overall object behavior and multiple state estimation object can be created and used.\r\n\r\n#### Example:\r\n```\r\nclass Stateestimation_perfect(mpcpy.Stateestimation):\r\n    # redefine the stateestimation method\r\n    def stateestimation(self,time):\r\n        state = {}\r\n        state['T_in'] = self.emulator.res['C_in.T'][-1]\r\n        state['T_em'] = self.emulator.res['C_em.T'][-1]\r\n        return state\r\n\r\nstateestimation = Stateestimation_perfect(emulator)\r\nprint( stateestimation(0) )\r\n```\r\n\r\n\t\t\t\r\n### Prediction\r\nThe `prediction` class is used to generate predictions from the boundary conditions over a certain time period.\r\nOn creation it takes a `boundaryconditions` object as argument.\r\nIt follows the same structure as the `Stateestimation` class but is predefined with a perfect prediction method.\r\nThis can of course be redefined to more realistic or stochastic prediction models.\r\n\r\n#### Example:\r\n```\r\nprediction = mpcpy.Prediction(boundaryconditions)\r\nprint( prediction([0.,1800.,3600.]) )\r\n```\r\n\r\n### Control\r\nThe `Control` class combines state estimations and predictions and solves an optimal control problem.\r\nThe class is built as a base class as the optimal control program will be different for every system.\r\nUpon initialization a `stateestimation` object, `prediction` object must be given. Several other arguments are optional.\r\nA `parameters=None` argument can be used to pass model parameters to the optimal control problem.\r\nThe `horizon=24*3600.` argument determines how far the optimal control problem will look into the future.\r\nThe `timestep=3600.` argument determines the discretization time step of the optimal control problem.\r\nThe `receding=3600.` argument determines the time between two control optimizations\r\n\r\nA `time` method is implemented which creates a control time array for the next control optimization based on a `starttime` argument and the above mentioned times.\r\nThe `__call__` method runs the state estimation, the predictions and tries to solve the optimal control problem.\r\nThe solving of the optimal control problem is done by calling the solution property which must contain a function which solves the problem and returns a dictionary of control inputs.\r\n\r\nThe solution function can be set by the `formulation` method.\r\nThis is done to avoid redefining the problem on every control time step which could be very slow for large optimal control problems.\r\nIn the base class the formulation method returns a blank solution function so this needs to be customized in a child class. \r\n\r\nIn the example below IBM Cplex is used as the optimization solver. More information on Cplex can be found below.\r\n\r\n#### Example:\r\n```\r\nimport cplex\r\nclass Linearprogram(mpcpy.Control):\r\n    def formulation(self):\r\n        # define temporary times, state estimations and prediction to use while defining the problem\r\n        time = self.time(0)\r\n        dt = time[1]-time[0]\r\n        N = len(time)\r\n        sta = self.stateestimation(time[0])\r\n        pre = self.prediction(time)\r\n        par = self.parameters\r\n\r\n        ocp = cplex.Cplex()\r\n\r\n        # shorthand for 1\r\n        ones = np.ones(N)\r\n\r\n        # add variables, don't wory about bounds yet as they will be set in the solution function\r\n        ocp.variables.add(names = ['Q_flow_hp[%s]'%(i) for i in range(N)])\r\n        ocp.variables.add(names = ['T_in[%s]'%(i) for i in range(N)])\r\n        ocp.variables.add(names = ['T_em[%s]'%(i) for i in range(N)])\r\n\r\n        # add state constraints\r\n        for i in range(N-1):\r\n            # T_in\r\n            # C_in/dt*(T_in[i+1]-T_in[i]) = UA_in_amb*(T_amb[i]-T_in[i]) + UA_em_in*(T_em[i]-T_in[i]) + Q_flow_sol[i]\r\n            ocp.linear_constraints.add(\r\n                    lin_expr = [[['T_in[%s]'%(i)                                   , 'T_in[%s]'%(i+1) , 'T_em[%s]'%(i)    ],\r\n                                 [-par['C_in']/dt+par['UA_in_amb']+par['UA_em_in'] , par['C_in']/dt   , -par['UA_em_in']  ]]],\r\n                    senses   = 'E',\r\n                    rhs      = [par['UA_in_amb']*pre['T_amb'][i] + pre['Q_flow_sol'][i] ],\r\n                    names    = ['state_T_in[%s]'%(i)])\r\n\r\n\r\n            # T_em\r\n            # C_em/dt*(T_em[i+1]-T_em[i]) = UA_em_in*(T_in[i]-T_em[i]) + Q_flow_hp[i]\r\n            ocp.linear_constraints.add(\r\n                    lin_expr = [[['T_em[%s]'%(i)                  , 'T_em[%s]'%(i+1) , 'T_in[%s]'%(i)    , 'Q_flow_hp[%s]'%(i) ],\r\n                                 [-par['C_em']/dt+par['UA_em_in'] ,  par['C_em']/dt  , -par['UA_em_in']  , -1                  ]]],\r\n                    senses   = 'E',\r\n                    rhs      = [0],\r\n                    names    = ['state_T_em[%s]'%(i)])\r\n\r\n        # add initial values\r\n        ocp.linear_constraints.add(lin_expr = [[['T_in[0]',   ],\r\n                                                 [1]]],\r\n                                   senses   = 'E',\r\n                                   rhs      = [sta['T_in'].item()],\r\n                                   names    = ['T_in_ini'])\r\n\r\n        ocp.linear_constraints.add(lin_expr = [[['T_em[0]',   ],\r\n                                                 [1]]],\r\n                                   senses   = 'E',\r\n                                   rhs      = [sta['T_em'].item()],\r\n                                   names    = ['T_em_ini'])\r\n            \r\n            \r\n        # disable output printing\r\n        ocp.set_log_stream(None)\r\n        #ocp.set_error_stream(None)\r\n        ocp.set_warning_stream(None)\r\n        ocp.set_results_stream(None)\r\n\r\n        self.ocp = ocp\r\n        \r\n        def solution(sta,pre):\r\n            # define the cost function\r\n            ocp.objective.set_linear( [('Q_flow_hp[%s]'%(i),par['COP']*pre['p_el'][i]/1000*dt/3600) for i in range(N)] )\r\n\r\n            # hard bounds\r\n            ocp.variables.set_lower_bounds( [('T_in[%s]'%(i)     ,pre['T_in_min'][i]) for i in range(N)])\r\n            ocp.variables.set_upper_bounds( [('Q_flow_hp[%s]'%(i),pre['Q_flow_hp_max'][i]) for i in range(N)]\r\n                                           +[('T_em[%s]'%(i)     ,pre['T_em_max'][i]) for i in range(N)])\r\n            \r\n            \r\n            # state constraints\r\n            ocp.linear_constraints.set_rhs( [('state_T_in[%s]'%(i),par['UA_in_amb']*pre['T_amb'][i] + pre['Q_flow_sol'][i]) for i in range(N-1)]\r\n                                           +[('state_T_em[%s]'%(i),0) for i in range(N-1)] )\r\n\r\n            # initial conditions\r\n            ocp.linear_constraints.set_rhs( [('T_in_ini',sta['T_in'].item())]\r\n                                           +[('T_em_ini',sta['T_em'].item())] )\r\n            \r\n            # solve the optimal control problem\r\n            ocp.solve()\r\n\r\n            # add a properties with the ocp problem with the solution for inspection\r\n            self.ocp = ocp\r\n\r\n            # return the contol inputs\r\n            sol = {}\r\n            sol['time'] = pre['time']\r\n            sol['Q_flow_hp'] = ocp.solution.get_values(['Q_flow_hp[%s]'%(i) for i in range(N)])\r\n\r\n            return sol\r\n\r\n        return solution\r\n\r\n\r\ncontrol_parameters = {'C_in': emulator_parameters['C_in.C'],\r\n                      'C_em': emulator_parameters['C_em.C'],\r\n                      'UA_in_amb': emulator_parameters['UA_in_amb.G'],\r\n                      'UA_em_in': emulator_parameters['UA_em_in.G'],\r\n                      'COP': 4}\r\ncontrol = Linearprogram(stateestimation,prediction,parameters=control_parameters,horizon=24*3600.,timestep=3600.,receding=3600.)\r\n\r\nprint( control.ocp.solution.get_status() )\r\nprint( control(0) )\r\n```\r\n\r\n\r\n## MPC\r\nEverything comes together in the `MPC` class. This creates a callable object which runs the MPC and returns a result dictionary from the emulator.\r\n\r\n```\r\nmpc = mpcpy.MPC(emulator,control,boundaryconditions,emulationtime=1*24*3600.,resulttimestep=600)\r\nres = mpc()\r\nprint(res['Q_flow_hp'])\r\n```\r\n\r\n\r\n\r\n# Cplex in Python\r\nIBM ILOG CPlex has it's own API for python. \r\n\r\n## Installation\r\nThe following instructions were adapted from [here](http://www-01.ibm.com/support/knowledgecenter/SSSA5P_12.6.2/ilog.odms.cplex.help/CPLEX/GettingStarted/topics/set_up/Python_setup.html?lang=en)\r\nGo to the directory you installed CPlex in 'YOURCPLEXDIR', on windows this could be `C:\\Program Files (x86)\\IBM\\ILOG\\CPLEX_Studio1261\\cplex`.\r\nnow go to `YOURCPLEXDIR/python/VERSION/PLATFORM` where VERSION is your python version (2.7 or 3.4 most likely) and PLATFORM is your platform (for instance x86_win32 on a 32 bit windows computer). \r\n\r\nNow it is best to install the cplex package in your package directory ('YOURPYTHONPACKAGEDIR') as this is where python searches for packages.\r\nOn a windows system with python 2.7 this is probably `C:\\Python27\\Lib\\site-packages`\r\nThis is done by running the following command in a terminal:\r\n```\r\npython setup.py install --home YOURPYTHONPACKAGEDIR/cplex\r\n```\r\n\r\nAfter this is done you should be able to run the rest of the code presented below.\r\n\r\n\r\n## Workflow\r\nThe use of Cplex in python will here be explained by defining, solving and processing the output of an optimal control problem (OCP).\r\n\r\nTo start using the Cplex python API first import it and import numpy for array handling\r\n```\r\nimport cplex\r\nimport numpy as np\r\n```\r\na new optimization problem can be created with:\r\n```\r\nocp = cplex.Cplex()\r\n```\r\n\r\nWe will define some parameters to use in the example, they are of no importance.\r\n```\r\n# number of time points in the OCP\r\nN = 25\r\ndt = 3600.\r\ntime = np.arange(N)*dt\r\n\r\n# prediction dictionary\r\npre = {'T_in_min': 20*np.ones(N),\r\n       'T_em_max': 30*np.ones(N),\r\n       'T_amb': 5 + 5*np.sin(2*np.pi*(time/24/3600-0.6)),\r\n       'Q_flow_hp_max': 5000*np.ones(N),\r\n       'Q_flow_sol': np.clip(2000*np.sin(2*np.pi*(time/24/3600-0.4)),0,10000),\r\n       'p_el': np.clip( 0.18 + 0.10*np.sin(2*np.pi*(time/24/3600-0.0)),0,0.24 )}\r\n\r\n# parameter dictionary\r\npar = {'COP': 4,\r\n       'C_in': 10e6,\r\n       'C_em': 20e6,\r\n       'UA_in_amb': 200,\r\n       'UA_em_in': 1600}\r\n```\r\n\r\n### Variables\r\nVariable must be added to the problem using the `cplex.variables.add` method. This method has several keyword arguments  all of which must all be a list of values.\r\nAll supplied arguments must have equal length. Arguments are:\r\n- `names`: list of strings, variable names which can be used to reference the variable\r\n- `obj`: list of floats, coefficient of the linear objective function accompanying the variable\r\n- `lb`: list of floats, lower bounds of the variables, defaults to 0\r\n- `ub`: list of floats, upper bounds of the variables, defaults to 1e20\r\n- `type`: list of single character strings 'c','i','b' for continuous, integer, binary variables respectively?\r\nCplex is suitable for solving Mixed Integer Programs.\r\n\r\nWhen defining an optimal control problem is is easy to use list comprehensions built into python together with string formatting to generate meaningful names for all variables.\r\nThese names will then refer to the correct column in the constraint and objective matrices.\r\n```\r\nocp.variables.add(names = ['Q_flow_hp[{0}]'.format(i) for i in range(N)])\r\nocp.variables.add(names = ['T_in[{0}]'.format(i) for i in range(N)])\r\nocp.variables.add(names = ['T_em[{0}]'.format(i) for i in range(N)])\r\n```\r\n\r\nBoundaries for the variables can be set during variable creation or using the methods `cplex.variable.set_lower_bounds` and `cplex.variable.set_upper_bounds`.\r\nThese methods accept either a variable name/index, value pair or a list of variable name/index, value pair tuples. Again using list comprehensions makes everything easy.\r\nIt is preferred to make few calls of a function with a larger set of variables than the other way around as this reduced overhead.\r\n```\r\nocp.variables.set_lower_bounds( 'T_in[0]',pre['T_in_min'][0] )\r\n# or\r\nocp.variables.set_lower_bounds( [('T_in[{0}]'.format(i)     ,pre['T_in_min'][i]) for i in range(N)] )\r\nocp.variables.set_upper_bounds( [('Q_flow_hp[{0}]'.format(i),pre['Q_flow_hp_max'][i]) for i in range(N)]\r\n                               +[('T_em[{0}]'.format(i)     ,pre['T_em_max'][i]) for i in range(N)] )\r\n```\r\n\r\nFor most \"set\" methods in cplex there is a corresponding \"get\" method which can be used to retrieve values.\r\n\r\n### Objective\r\nThe objective function can have linear and quadratic terms quadratic, cplex will select an appropriate solution method automatically.\r\n\r\nThe linear terms in the objective function can be defined using `cplex.objective.set_linear`.\r\nThis function accepts the same input argument format as the `cplex.variables.set_lower_bounds` method explained above.\r\n```\r\nocp.objective.set_linear( 'Q_flow_hp[0]', par['COP']*pre['p_el'][0]/1000*dt/3600 )\r\n# or\r\nocp.objective.set_linear( [('Q_flow_hp[{0}]'.format(i), par['COP']*pre['p_el'][i]/1000*dt/3600) for i in range(N)] ))\r\n```\r\n\r\nQuadratic terms in the objective function are easiest to define with `cplex.objective.set_quadratic_coefficients`.\r\nNow 3 arguments or a list of tuples of 3 must be given containing two variables and the value. \r\nOf course care must be taken that the quadratic part remains positive semidefinite or the problem will become non-convex.\r\nIn the example below a small cost is given to the square of some variables:\r\n```\r\nocp.objective.set_quadratic_coefficients( [('Q_flow_hp[%s]'%(i),'Q_flow_hp[%s]'%(i),0.01*par['COP']*pre['p_el'][i]/1000*dt/3600) for i in range(N)] )\r\n```\r\n\r\n### Constraints\r\nBoth linear and quadratic constraints can be defined and reside in separate attributes.\r\n\r\nLinear constraints can be added to the problem with `cplex.linear_constraints.add`.\r\nIt accepts the following keyword arguments:\r\n- lin_expr: list of matrices in list of lists format or a list of cplex sparce pairs, expresses the lhs of the constraint\r\n- senses: list of single character strings which, expresses the sense of the constraint, 'G','L','E','R' for Greater, Lesser, Equal and Ranged respectively \r\n- rhs: list of floats, specifies the rhs of the constraints\r\n- range_values: list of floats specifying a range for the rhs if range_values[i] > 0 : rhs[i] <= a*x <= rhs[i]+range_values[i] else rhs[i]+range_values[i] <= a*x <= rhs[i]\r\n- names: a list of strings, names for the constraints\r\n\r\nAn custom cplex type has come up, the `cplex.SparsePair`. This type assigns values to an index which is referred to.\r\nThe example below can be used to assign values to the row of `T_in[0]` and `T_in[1]` in some constraint:\r\n```\r\ncplex.SparsePair(ind = ['T_in[0]', 'T_in[1]'], val = [5.0, 6.5])\r\n```\r\n\r\nFor the optimal control problem at hand the equations have to be discretized manually (leaving you the freedom to choose how to discretize).\r\nAgain list comprehensions are useful when adding constraints to our problem:\r\n```\r\n# state constraints for T_in\r\n# C_in/dt*(T_in[i+1]-T_in[i]) = UA_in_amb*(T_amb[i]-T_in[i]) + UA_em_in*(T_em[i]-T_in[i]) + Q_flow_sol[i]\r\n\r\n\r\nocp.linear_constraints.add( lin_expr = [ [['T_in[{0}]'.format(i)                           , 'T_in[{0}]'.format(i+1), 'T_em[{0}]'.format(i) ],\r\n                                          [-par['C_in']/dt+par['UA_in_amb']+par['UA_em_in'], par['C_in']/dt         , -par['UA_em_in']      ]] for i in range(N-1)],\r\n                            senses   = ['E' for i in range(N-1)],\r\n                            rhs      = [par['UA_in_amb']*pre['T_amb'][i] + pre['Q_flow_sol'][i] for i in range(N-1)],\r\n                            names    = ['state_T_in[{0}]'.format(i) for i in range(N-1)] )\r\n\r\n# or\r\n# state constraints for T_em\r\n# C_em/dt*(T_em[i+1]-T_em[i]) = UA_em_in*(T_in[i]-T_em[i]) + Q_flow_hp[i]\r\nocp.linear_constraints.add( lin_expr = [ cplex.SparsePair( ind = ['T_em[{0}]'.format(i)          , 'T_em[{0}]'.format(i+1), 'T_in[{0}]'.format(i) , 'Q_flow_hp[{0}]'.format(i) ], \r\n                                                           val = [-par['C_em']/dt+par['UA_em_in'], par['C_em']/dt         , -par['UA_em_in']      , -1                         ]\r\n                                                          ) for i in range(N-1)],\r\n                            senses   = ['E' for i in range(N-1)],\r\n                            rhs      = [0 for i in range(N-1)],\r\n                            names    = ['state_T_em[{0}]'.format(i) for i in range(N-1)] )\r\n```\r\n\r\nOur problem also needs initial values which are also equality constraints:\r\n```\r\n# add initial values\r\nocp.linear_constraints.add(lin_expr = [[['T_in[0]'],\r\n                                        [1        ]]],\r\n                           senses   = 'E',\r\n                           rhs      = [21],\r\n                           names    = ['T_in_ini'])\r\n\r\nocp.linear_constraints.add(lin_expr = [[['T_em[0]'],\r\n                                        [1        ]]],\r\n                           senses   = 'E',\r\n                           rhs      = [22],\r\n                           names    = ['T_em_ini'])\r\n```\r\n\r\nWhen using the OCP in a model predictive control strategy it is common that the bounds and right hand side of constraints change.\r\nAs this is only a small change in the large OCP it is appropriate to only change this part of the OCP reducing unnecessary computations.\r\nThis can be done with the `cplex.linear_constraints.set_rhs` method.\r\nIt accepts a list of tuples containing a constraint name/index and a value just like `cplex.variable.set_lower_bounds` and `cplex.objective.set_linear` :\r\n```\r\nocp.linear_constraints.set_rhs( [('state_T_in[{0}]'.format(i),par['UA_in_amb']*pre['T_amb'][i] + pre['Q_flow_sol'][i]) for i in range(N-1)]  \r\n                               +[('state_T_em[{0}]'.format(i),0) for i in range(N-1)] )\r\n```\r\n           \r\n### Solving and retrieving the solution\r\nSolving is easy:\r\n```\r\nocp.solve()\r\n```\r\ncplex does the rest.\r\n\r\nYou can suppress output if required with the following commands:\r\n```\r\nocp.set_log_stream(None)\r\nocp.set_error_stream(None)\r\nocp.set_warning_stream(None)\r\nocp.set_results_stream(None)\r\n```\r\n\r\nRetrieving the solution is equally easy, pay attention though that cplex returns regular lists, not numpy arrays, best to convert them immediately:\r\n```\r\nsol = {}\r\nsol['Q_flow_hp'] = np.array(ocp.solution.get_values(['Q_flow_hp[{0}]'.format(i) for i in range(N)]))\r\nsol['T_in']      = np.array(ocp.solution.get_values(['T_in[{0}]'.format(i) for i in range(N)]))\r\nsol['T_em']     = np.array(ocp.solution.get_values(['T_em[{0}]'.format(i) for i in range(N)]))\r\nprint(sol['T_in'])\r\n```\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}